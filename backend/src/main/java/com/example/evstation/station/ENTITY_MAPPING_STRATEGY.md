# Station Entity Mapping Strategy

## Tổng quan

Hệ thống sử dụng **versioning pattern** để quản lý dữ liệu trạm sạc:
- `Station` = Định danh địa điểm (immutable identifier)
- `StationVersion` = Dữ liệu theo phiên bản (workflow status)
- Chỉ 1 `StationVersion` có status `PUBLISHED` tại một thời điểm (enforced by partial unique index)

## Mapping Strategy

### 1. Station Entity
```
station
├── id: UUID (PK)
├── provider_id: UUID (FK → user_account, nullable)
└── created_at: Timestamp
```

**Domain Entity**: `Station`
- Pure Java class (no JPA annotations in domain)
- Repository port: `StationRepository`

**JPA Entity**: `StationEntity` (infrastructure/jpa)
- `@Entity`, `@Table`, JPA annotations
- Adapter: `StationRepositoryAdapter` implements `StationRepository`

---

### 2. StationVersion Entity
```
station_version
├── id: UUID (PK)
├── station_id: UUID (FK → station)
├── version_no: Integer (unique per station)
├── workflow_status: ENUM (DRAFT | PENDING | PUBLISHED | REJECTED | ARCHIVED)
├── name: Text
├── address: Text
├── location: geography(Point,4326) ← PostGIS
├── operating_hours: Text
├── parking: ENUM (PAID | FREE | UNKNOWN)
├── visibility: ENUM (PUBLIC | PRIVATE | RESTRICTED)
├── public_status: ENUM (ACTIVE | INACTIVE | MAINTENANCE)
├── created_by: UUID (FK → user_account)
├── created_at: Timestamp
└── published_at: Timestamp (nullable)
```

**Domain Entity**: `StationVersion`
- Value objects: `WorkflowStatus`, `ParkingType`, `VisibilityType`, `PublicStatus`
- Location: Use `Point` value object (WKT string in domain, PostGIS in infrastructure)

**JPA Entity**: `StationVersionEntity`
- `@Type(PostgisGeometryType.class)` for location field
- `@Enumerated(EnumType.STRING)` for enums
- Partial unique constraint enforced by database

**Key Business Rules**:
- Only 1 PUBLISHED version per station (DB constraint)
- `published_at` must be set when status = PUBLISHED (check constraint)

---

### 3. StationService Entity
```
station_service
├── id: UUID (PK)
├── station_version_id: UUID (FK → station_version)
└── service_type: ENUM (CHARGING | BATTERY_SWAP)
```

**Domain Entity**: `StationService`
- Value object: `ServiceType`

**JPA Entity**: `StationServiceEntity`
- One-to-Many with `StationVersion`

---

### 4. ChargingPort Entity
```
charging_port
├── id: UUID (PK)
├── station_service_id: UUID (FK → station_service)
├── power_type: ENUM (DC | AC)
├── power_kw: Numeric (nullable - null for AC)
└── port_count: Integer (>= 0)
```

**Domain Entity**: `ChargingPort`
- Value objects: `PowerType`
- Business rule: `power_kw` required when `power_type = DC`, null when AC

**JPA Entity**: `ChargingPortEntity`
- One-to-Many with `StationService`

**Mapping Strategy**:
- CSV input: `ports_250kw=4, ports_ac=1`
- Normalized to rows:
  - `(DC, 250, 4)` - 4 ports of 250kW DC
  - `(AC, null, 1)` - 1 port AC (no power_kw)

---

### 5. ChangeRequest Entity
```
change_request
├── id: UUID (PK)
├── type: ENUM (CREATE_STATION | UPDATE_STATION)
├── status: ENUM (DRAFT | PENDING | APPROVED | REJECTED | PUBLISHED)
├── station_id: UUID (nullable - null when CREATE)
├── proposed_station_version_id: UUID (FK → station_version)
├── submitted_by: UUID (FK → user_account)
├── risk_score: Integer (0-100)
├── risk_reasons: JSONB (array of strings)
├── admin_note: Text (nullable)
├── created_at: Timestamp
├── submitted_at: Timestamp (nullable)
└── decided_at: Timestamp (nullable)
```

**Domain Entity**: `ChangeRequest`
- Value objects: `ChangeRequestType`, `ChangeRequestStatus`
- Business rules:
  - `station_id` required when type = UPDATE_STATION
  - `station_id` null when type = CREATE_STATION
  - Timestamps validated by check constraints

**JPA Entity**: `ChangeRequestEntity`
- `@Type(JsonBinaryType.class)` for `risk_reasons` JSONB field

---

### 6. AuditLog Entity
```
audit_log
├── id: UUID (PK, auto-generated)
├── actor_id: UUID (FK → user_account)
├── actor_role: Text
├── action: Text
├── entity_type: Text
├── entity_id: UUID (nullable)
├── metadata: JSONB
└── created_at: Timestamp
```

**Domain Entity**: `AuditLog`
- Value object: `AuditAction`, `AuditEntityType`

**JPA Entity**: `AuditLogEntity`
- `@Type(JsonBinaryType.class)` for metadata
- ID auto-generated by database

---

## Layer Structure

### Domain Layer (pure Java)
```
station/domain/
├── Station.java
├── StationVersion.java
├── StationService.java
├── ChargingPort.java
├── ChangeRequest.java
├── AuditLog.java
└── [value objects]/
    ├── WorkflowStatus.java
    ├── ParkingType.java
    ├── VisibilityType.java
    ├── PublicStatus.java
    ├── ServiceType.java
    ├── PowerType.java
    └── ...
```

### Infrastructure Layer (JPA)
```
station/infrastructure/jpa/
├── StationEntity.java
├── StationVersionEntity.java
├── StationServiceEntity.java
├── ChargingPortEntity.java
├── ChangeRequestEntity.java
├── AuditLogEntity.java
├── StationJpaRepository.java (Spring Data JPA)
└── StationRepositoryAdapter.java (implements domain port)
```

### Application Layer
```
station/application/
├── port/
│   ├── StationRepository.java
│   └── ...
└── [use cases]/
```

---

## Key Design Decisions

1. **Versioning Pattern**: `Station` (identifier) + `StationVersion` (data)
2. **PostGIS Integration**: Use `geography(Point,4326)` for location (WGS84)
3. **Normalized Charging Ports**: Rows instead of columns (ports_250kw, ports_120kw...)
4. **JSONB for Flexible Data**: `risk_reasons`, `metadata` fields
5. **Invariants Enforced by DB**: Partial unique index, check constraints
6. **Clean Architecture**: Domain entities have no JPA dependencies

